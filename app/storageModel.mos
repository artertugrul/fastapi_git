model StorageModel
uses "mmxprs"; !gain access to the Xpress-Optimizer solver
!uses "advmod"

(! CS Changes
18/09/12 	- Replaced OPTPERIODS by PERIODS in the mpvar and linctr definitions (to fit with mpproblem implementation)
			- Implemented mpproblem within the loop over subproblems (removing need to hide constraints)
			- Modified generateConstraints to use OPTPERIODS directly and no longer calculate offsets
			- Modified writeResults to use SAVEDPERIODS and no longer apply offsets
			- Removed code to clear constraints
!)

options noimplicit
options noautofinal

!optional parameters section
parameters
	inputDir = 'C:\xpress_runs\in'
	outputDir = 'C:\xpress_runs\out'
	inp_periodLength = 1
	PENALTY = 999999
end-parameters

! forward declarations for procedures and functions
forward procedure readControlFile

! procedures for formulating new constraints
forward procedure generateConstraints(OPTPERIODS: range, initStorage: real, initCharge: real, initDischarge: real, subProb: integer)
forward procedure setupImbalForecast

! procedures for writing out the results
forward procedure writeResults(SAVEDPERIODS: range)
forward procedure writeFile(filename:string, source:array(p: range, q: range) of real, writeMode: integer)
forward procedure writeFile(filename:string, source:array(p: range) of real, writeMode: integer)
forward procedure writeFile(filename:string, source:real, writeMode: integer)

! 1d readFile declarations
forward procedure readSparseFile(filename:string, dest:array(p: range) of real)
forward procedure readSparseFile(filename:string, dest:array(p: range) of integer)
forward procedure readSparseFile(filename:string, dest:array(p: range) of boolean)

! 2d readFile declarations
forward procedure readSparseFile(filename:string, dest:array(p: range, q: range) of real)
forward procedure readSparseFile(filename:string, dest:array(p: range,q: range) of boolean)
forward procedure readSparseFile(filename:string, dest:array(p: range,q: range) of integer)

! declare arrays for the input data
declarations
	! copy of input parameter to allow override
	periodLength: real

	! non time-varying options
	nPeriods: integer
	nResProducts: integer
	nImbalTranches: integer
	nCapacityCharges: integer	! 1 = yes, 2 = no
	nImportCharges: integer
	nExportCharges: integer
	onSiteGenPresent: boolean
	onSiteDemPresent: boolean
	allowGenCurtailment: boolean
	minPower: real
	minPowerDuration: real
	allowFuelProduction: boolean
	!incGridCharges: boolean
	blockSize: integer
	runOutPeriods: integer
	maxTime: integer ! maximum time to spend optimising
	balanceLossMethod: integer ! 1 = exact, 2 = assign loss factors assuming battery output = 0 (no charging/discharging)
	relTol: real
	absTol: real
	allowArbitrage: integer
	maxImbalForecastHours: integer
	nImbalForecastTranches: integer
	imbalModelType: integer
	allowImbalanceAdjustment: boolean
	tradingHorizon: integer
	takeDemandFromStorage: boolean
	nCapChargePeriods: integer

	! variables to keep track of which block is currently being optimised
	nBlocks: integer
	blockStart: integer
	blockEnd: integer
	blockRunOutEnd: integer

	! define ranges
	PERIODS: range
	RESERVE: range
	CAPACITYCHARGES: range
	IMPORTCHARGES: range
	EXPORTCHARGES: range
	CAPCHARGEPERIODS: range

	CAPCHARGEDATA: range
	GRIDCHARGEDATA: range 	! CS

	OPTPERIODS: range
	SAVEDPERIODS: range

	TRANCHES: range
	IMBALFORECASTHOURS: range
	IMBALFORECASTTRANCHES: range

	! parameters
	capacity: real
	storageEff: array(PERIODS) of real
	maxDischarge: array(PERIODS) of real
	dischargeEff: array(PERIODS) of real
	dischargeRamp: array(PERIODS) of real
	dischargeRDR: array(PERIODS) of real
	dischargeFuelPrice: array(PERIODS) of real
	dischargeFuelConsumption: array(PERIODS) of real
	maxCharge: array(PERIODS) of real
	chargeEff: array(PERIODS) of real
	chargeRamp: array(PERIODS) of real
	chargeRDR: array(PERIODS) of real
	chargeFuelPrice: array(PERIODS) of real
	chargeFuelConsumption: array(PERIODS) of real
	chargeCost: array(PERIODS) of real
	dischargeCost: array(PERIODS) of real

	! market data
	demand: array(PERIODS) of real
	generation: array(PERIODS) of real
	maxBuy: real
	maxSell: real
	buyPrice: array(PERIODS) of real
	sellPrice: array(PERIODS) of real

	outputFuelPrice: array(PERIODS) of real
	maxFuelProduction: array(PERIODS) of real
	fuelConversionFactor: array(PERIODS) of real

	! reserve data
	resTimescales: array(RESERVE) of real
	maxReserve: array(RESERVE) of real
	nResPeriods: array(RESERVE) of integer
	incBalEnergy: array(RESERVE) of real
	resPrice: array(PERIODS,RESERVE) of real
	incBalPrice: array(PERIODS,RESERVE) of real
	decBalEnergy: array(RESERVE) of real
	decBalPrice: array(PERIODS,RESERVE) of real
	resSellPeriod: array(RESERVE) of integer
	resSymmetrical: array(RESERVE) of integer
	resApplies: array(PERIODS,RESERVE) of boolean
	resPeriod: array(PERIODS,RESERVE) of integer
	customReservePeriod: array(PERIODS,RESERVE) of integer

	resMinCharge: array(RESERVE) of real
	resMinDischarge: array(RESERVE) of real
	resWorstCaseCall: array(RESERVE) of real

	! imbalance data

	! data read in to the model but processed into another form before use
	imbalanceActuals: array(PERIODS) of real
	imbalForDecCallProb: array(IMBALFORECASTHOURS,TRANCHES) of real
	imbalForDecSize: array(IMBALFORECASTHOURS) of real
	imbalForCoeffs: array(IMBALFORECASTHOURS,IMBALFORECASTTRANCHES) of real
	imbalForConsts: array(IMBALFORECASTHOURS,IMBALFORECASTTRANCHES) of real
	imbalForBoundaries: array(IMBALFORECASTTRANCHES) of real
	imbalForIncCallProb: array(IMBALFORECASTHOURS,TRANCHES) of real
	imbalForIncSize: array(IMBALFORECASTHOURS) of real

	imbalShortfallActual: array(PERIODS) of real
	imbalShortfallTranches: array(IMBALFORECASTTRANCHES) of real
	imbalShortfallCoeffs: array(IMBALFORECASTHOURS,IMBALFORECASTTRANCHES) of real
	imbalShortfallConsts: array(IMBALFORECASTHOURS,IMBALFORECASTTRANCHES) of real

	imbalExcessActual: array(PERIODS) of real
	imbalExcessTranches: array(IMBALFORECASTTRANCHES) of real
	imbalExcessCoeffs: array(IMBALFORECASTHOURS,IMBALFORECASTTRANCHES) of real
	imbalExcessConsts: array(IMBALFORECASTHOURS,IMBALFORECASTTRANCHES) of real

	! data used in the optimisation
	imbalIncSize: array(PERIODS,TRANCHES) of real
	imbalShortfallPrice: array(PERIODS) of real
	imbalIncProb: array(PERIODS,TRANCHES) of real
	incImbalCallLength: real ! need to clarify how to use this input

	imbalDecSize: array(PERIODS,TRANCHES) of real
	imbalExcessPrice: array(PERIODS) of real
	imbalDecProb: array(PERIODS,TRANCHES) of real
	decImbalCallLength: real ! need to clarify how to use this input

	! peak demand data
	!peakDemCharges: array(PERIODS) of real

	! CS: Grid charges
	capChargeData: dynamic array(CAPACITYCHARGES,CAPCHARGEDATA) of real
	lowerCapCharge: array(CAPACITYCHARGES) of real
	capBreakpoint: array(CAPACITYCHARGES) of real
	upperCapCharge: array(CAPACITYCHARGES) of real
	capChargeApplies: array(PERIODS,CAPACITYCHARGES) of integer
	capChargeAverage: array(CAPACITYCHARGES) of boolean

	! import and export charges
	importChargeData: dynamic array(IMPORTCHARGES, GRIDCHARGEDATA) of real
	lowerImportCharge: array(IMPORTCHARGES) of real
	importBreakpoint: array(IMPORTCHARGES) of real
	upperImportCharge: array(IMPORTCHARGES) of real
	importChargeApplies: array(PERIODS,IMPORTCHARGES) of boolean

	exportChargeData: dynamic array(IMPORTCHARGES, GRIDCHARGEDATA) of real
	lowerExportCharge: array(EXPORTCHARGES) of real
	exportBreakpoint: array(EXPORTCHARGES) of real
	upperExportCharge: array(EXPORTCHARGES) of real
	exportChargeApplies: array(PERIODS,EXPORTCHARGES) of boolean

	! variables to keep track of total imports and exports so far
	totalExportsToNow: real
	totalImportsToNow: real

	! calendar data
	weekID: array(PERIODS) of integer
	monthID: array(PERIODS) of integer
	isWD: array(PERIODS) of boolean
	dayID: array(PERIODS) of integer

	! calculated intermediate values
	initialStorage: real
	initialCharging: real
	initialDischarging: real
	storageCost: real
	currResPeriod: integer
	currMaxRes: real

	! store the adjustments to the imbalance schedule
	totalImbalSales: array(PERIODS) of real
	maxImbalSales: array(PERIODS) of real
	maxImbalPurchases: array(PERIODS) of real
end-declarations

! CB: THESE NEED TO BE IN GLOBAL SCOPE BECAUSE DATA IS WRITTEN OUT RIGHT AT THE END
declarations
	! reserve outputs
	resProvision: array(PERIODS, RESERVE) of real
	resIncome: array(PERIODS, RESERVE) of real

	! balancing outputs
	balStorage: array(PERIODS,RESERVE) of real
	balIncome: array(PERIODS, RESERVE) of real
	balCost: array(PERIODS,RESERVE) of real
end-declarations

! copy periodLength from the input parameter
periodLength := inp_periodLength

! read in control file parameters
readControlFile

! set-up the periods range
PERIODS := 1..nPeriods
finalize(PERIODS)

if nResProducts > 0 then
	RESERVE := 1..nResProducts
	finalize(RESERVE)
end-if

if nImbalTranches > 0 then
	TRANCHES := 1..nImbalTranches
	!finalize(TRANCHES)
end-if

if nImbalForecastTranches > 0 then
	IMBALFORECASTTRANCHES := 1..nImbalForecastTranches
end-if

if maxImbalForecastHours > 0 then
	IMBALFORECASTHOURS := 1..maxImbalForecastHours
elif imbalModelType = 1 then
	IMBALFORECASTHOURS := 1..1
end-if

! CS: initialise GRID charges
GRIDCHARGEDATA := 1..3
finalize(GRIDCHARGEDATA)

CAPCHARGEDATA := 1..4
finalize(CAPCHARGEDATA)

if nCapacityCharges > 0 then
	CAPACITYCHARGES := 1..nCapacityCharges
	finalize(CAPACITYCHARGES)

	CAPCHARGEPERIODS := 1..nCapChargePeriods
	finalize(CAPCHARGEPERIODS)
end-if

if nImportCharges > 0 then
	IMPORTCHARGES := 1..nImportCharges
	finalize(IMPORTCHARGES)
end-if

if nExportCharges > 0 then
	EXPORTCHARGES := 1..nExportCharges
	finalize(EXPORTCHARGES)
end-if

!----------------------------------------------------------------------------------------
! read in the optimiser inputs

readSparseFile(inputDir + '\storageEfficiency.in',storageEff)
readSparseFile(inputDir + '\reserveSellPeriod.in',resSellPeriod)
readSparseFile(inputDir + '\reserveMaxVolume.in',maxReserve)
readSparseFile(inputDir + '\reserveMinCharge.in',resMinCharge)
readSparseFile(inputDir + '\reserveMinDischarge.in',resMinDischarge)
readSparseFile(inputDir + '\reserveWorstCaseCall.in',resWorstCaseCall)
readSparseFile(inputDir + '\reserveDirection.in',resSymmetrical)
readSparseFile(inputDir + '\reserveApplies.in',resApplies)
readSparseFile(inputDir + '\outputFuelPrice.in',outputFuelPrice)
readSparseFile(inputDir + '\maxFuelProduction.in',maxFuelProduction)
readSparseFile(inputDir + '\maxDischargePower.in',maxDischarge)
readSparseFile(inputDir + '\maxChargePower.in',maxCharge)
readSparseFile(inputDir + '\fuelConversionFactor.in',fuelConversionFactor)
readSparseFile(inputDir + '\dischargeRunDown.in',dischargeRDR)
readSparseFile(inputDir + '\dischargeRamp.in',dischargeRamp)
readSparseFile(inputDir + '\dischargeFuelPrice.in',dischargeFuelPrice)
readSparseFile(inputDir + '\dischargeFuelConsumption.in',dischargeFuelConsumption)
readSparseFile(inputDir + '\dischargeEfficiency.in',dischargeEff)
readSparseFile(inputDir + '\chargeRunDown.in',chargeRDR)
readSparseFile(inputDir + '\chargeRamp.in',chargeRamp)
readSparseFile(inputDir + '\chargeFuelPrice.in',chargeFuelPrice)
readSparseFile(inputDir + '\chargeFuelConsumption.in',chargeFuelConsumption)
readSparseFile(inputDir + '\chargeEfficiency.in',chargeEff)
readSparseFile(inputDir + '\balancingResponseTime.in',resTimescales)
readSparseFile(inputDir + '\balancingIncVol.in',incBalEnergy)
readSparseFile(inputDir + '\balancingDecVol.in',decBalEnergy)
readSparseFile(inputDir + '\weekID.in',weekID)
readSparseFile(inputDir + '\sellPrices.in',sellPrice)
readSparseFile(inputDir + '\monthID.in',monthID)
readSparseFile(inputDir + '\isWeekday.in',isWD)
readSparseFile(inputDir + '\generation.in',generation)
readSparseFile(inputDir + '\demand.in',demand)
readSparseFile(inputDir + '\dayID.in',dayID)
readSparseFile(inputDir + '\buyPrices.in',buyPrice)

if nResProducts > 0 then
	readSparseFile(inputDir + '\reservePrices.in',resPrice)
	readSparseFile(inputDir + '\reserveCustomPeriods.in', customReservePeriod)
	readSparseFile(inputDir + '\incBalPrices.in',incBalPrice)
	readSparseFile(inputDir + '\decBalPrices.in',decBalPrice)
end-if

! read in the imbalance volume data
readSparseFile(inputDir + '\imbalanceActuals.in',imbalanceActuals)
readSparseFile(inputDir + '\imbalanceShortfall.in',imbalShortfallActual)
readSparseFile(inputDir + '\imbalanceExcess.in',imbalExcessActual)

if imbalModelType >= 1 then
	readSparseFile(inputDir + '\imbalanceDecCallProb.in',imbalForDecCallProb)
	readSparseFile(inputDir + '\imbalanceIncCallProb.in',imbalForIncCallProb)
	readSparseFile(inputDir + '\imbalanceDecTrancheSize.in',imbalForDecSize)
	readSparseFile(inputDir + '\imbalanceIncTrancheSize.in',imbalForIncSize)
end-if

if imbalModelType = 2 then
	readSparseFile(inputDir + '\imbalanceForecastCoeffs.in',imbalForCoeffs)
	readSparseFile(inputDir + '\imbalanceForecastConsts.in',imbalForConsts)
	readSparseFile(inputDir + '\imbalanceForecastTrancheSize.in',imbalForBoundaries)

	readSparseFile(inputDir + '\imbalanceShortPriceTrancheSize.in',imbalShortfallTranches)
	readSparseFile(inputDir + '\imbalanceShortPriceCoeffs.in',imbalShortfallCoeffs)
	readSparseFile(inputDir + '\imbalanceShortPriceConsts.in',imbalShortfallConsts)

	readSparseFile(inputDir + '\imbalanceLongPriceTrancheSize.in',imbalExcessTranches)
	readSparseFile(inputDir + '\imbalanceLongPriceCoeffs.in',imbalExcessCoeffs)
	readSparseFile(inputDir + '\imbalanceLongPriceConsts.in',imbalExcessConsts)
end-if

! double the number of tranches in the model to give the forecasting algorithm the
! ability to create extra inc/dec tranches
! this has to happen after the data has been read in because 'readSparseFile' uses the
! size of indexing range/set to decide how many rows and columns to read
if nImbalTranches > 0 then
	imbalIncSize(1,nImbalTranches*2) := 0
	finalize(TRANCHES)
	!TRANCHES := TRANCHES + ((nImbalTranches+1)..(2*nImbalTranches))
	!TRANCHES := 1..(2*nImbalTranches)
end-if

! CS; read in grid charges
if nCapacityCharges > 0 then
	readSparseFile(inputDir + '\capacityCharges.in',capChargeData)
	readSparseFile(inputDir + '\capacityChargeApplies.in',capChargeApplies)

	forall(c in CAPACITYCHARGES) do
		lowerCapCharge(c) := capChargeData(c,1)
		capBreakpoint(c) := capChargeData(c,2)
		upperCapCharge(c) := capChargeData(c,3)
		capChargeAverage(c) := capChargeData(c,4) > 0
	end-do
end-if

if nImportCharges > 0 then
	readSparseFile(inputDir + '\importCharges.in',importChargeData)
	readSparseFile(inputDir + '\importChargeApplies.in',importChargeApplies)

	forall(i in IMPORTCHARGES) do
		lowerImportCharge(i) := importChargeData(i,1)
		importBreakpoint(i) := importChargeData(i,2)
		upperImportCharge(i) := importChargeData(i,3)
	end-do
end-if

if nExportCharges > 0 then
	readSparseFile(inputDir + '\exportCharges.in',exportChargeData)
	readSparseFile(inputDir + '\exportChargeApplies.in',exportChargeApplies)

	forall(e in EXPORTCHARGES) do
		lowerExportCharge(e) := exportChargeData(e,1)
		exportBreakpoint(e) := exportChargeData(e,2)
		upperExportCharge(e) := exportChargeData(e,3)
	end-do
end-if

! declare arrays for the decision variables and constraints
! -----------------------------------------------------------------------------------------------------

declarations
	! battery behaviour variables
	isCharging: array(PERIODS) of mpvar
	charging: array(PERIODS) of mpvar
	discharging: array(PERIODS) of mpvar
	stored: array(PERIODS) of mpvar
	fuelDischarge: array(PERIODS) of mpvar

	! energy market variables
	isImporting: array(PERIODS) of mpvar
	purchase: array(PERIODS) of mpvar
	sell: array(PERIODS) of mpvar
	balanceBreakerBuy: array(PERIODS) of mpvar
	balanceBreakerSell: array(PERIODS) of mpvar
	buyBreaker: array(PERIODS) of mpvar
	sellBreaker: array(PERIODS) of mpvar
	generationSpill: array(PERIODS) of mpvar

	! run-up / run-down variables
	chargeInc: array(PERIODS) of mpvar
	chargeDec: array(PERIODS) of mpvar
	dischargeInc: array(PERIODS) of mpvar
	dischargeDec: array(PERIODS) of mpvar

	! reserve and imbalance variables
	incResCharge: array(PERIODS,RESERVE) of mpvar
	incResDischarge: array(PERIODS,RESERVE) of mpvar
	decResCharge: array(PERIODS,RESERVE) of mpvar
	decResDischarge: array(PERIODS, RESERVE) of mpvar

	incImbalCharge: array(PERIODS,TRANCHES) of mpvar
	incImbalDischarge: array(PERIODS,TRANCHES) of mpvar
	decImbalCharge: array(PERIODS,TRANCHES) of mpvar
	decImbalDischarge: array(PERIODS,TRANCHES) of mpvar

	incSwitched: array(PERIODS) of mpvar
	decSwitched: array(PERIODS) of mpvar

	soldRes: array(PERIODS,RESERVE) of mpvar
	peakImports: mpvar

	! to apply minimum charging/discharging constraints
	reserveCommit: array(PERIODS,RESERVE) of mpvar
	minCharge: array(PERIODS) of mpvar
	minDischarge: array(PERIODS) of mpvar
	minChargeApplies: array(PERIODS) of mpvar
	minDischargeApplies: array(PERIODS) of mpvar

	! variables for adjusting the imbalance schedule
	imbalanceSales: dynamic array(PERIODS,TRANCHES) of mpvar
	imbalancePurchases: dynamic array(PERIODS,TRANCHES) of mpvar
	imbalMarketDir: dynamic array(PERIODS) of mpvar

	!CS: extra variables for capacity charging
	!gridCapacity: mpvar
	lowerCapacity: array(CAPACITYCHARGES,CAPCHARGEPERIODS) of mpvar
	upperCapacity: array(CAPACITYCHARGES,CAPCHARGEPERIODS) of mpvar
	isFull: array(CAPACITYCHARGES,CAPCHARGEPERIODS) of mpvar

	! extra variables for import/export charging
	importVolume: array(PERIODS) of mpvar
	exportVolume: array(PERIODS) of mpvar

	lowerImportVol: array(IMPORTCHARGES) of mpvar
	upperImportVol: array(IMPORTCHARGES) of mpvar
	importIsFull: array(IMPORTCHARGES) of mpvar

	lowerExportVol: array(EXPORTCHARGES) of mpvar
	upperExportVol: array(EXPORTCHARGES) of mpvar
	exportIsFull: array(EXPORTCHARGES) of mpvar

	! expected imports should only go in one direction
	isExpImporting: array(PERIODS) of mpvar
	EXPFLOWONEDIR:  array(PERIODS) of linctr
	EXPEXPORTBINARY: array(PERIODS) of linctr
	EXPIMPORTBINARY: array(PERIODS) of linctr

	! constraints
	STOPARBITRAGE: array(PERIODS) of linctr
	ISIMPORTING: array(PERIODS) of linctr
	IMPORTLIMIT: array(PERIODS) of linctr
	EXPORTLIMIT: array(PERIODS) of linctr

	ENERGYBALANCE: array(PERIODS) of linctr
	PURCHASELIMIT: array(PERIODS) of linctr
	SELLLIMIT: array(PERIODS) of linctr
	STORAGELIMIT: array(PERIODS) of linctr
	CHARGELIMIT: array(PERIODS) of linctr
	DISCHARGELIMIT: array(PERIODS) of linctr
	ISCHARGINGBINARY: array(PERIODS) of linctr
	STORAGEBALANCE: array(PERIODS) of linctr

	CHARGINGRAMP: array(PERIODS) of linctr
	DISCHARGINGRAMP: array(PERIODS) of linctr
	STORAGERAMP: array(PERIODS) of linctr
	OBJECTIVE: linctr

	! calculate the expected imports and exports
	EXPFLOW: array(PERIODS) of linctr
	EXPIMPORT: array(PERIODS) of linctr
	EXPEXPORT: array(PERIODS) of linctr

	! reserve and imbalance constraints
	INCSWITCHEDBINARY: array(PERIODS) of linctr
	INCHASSWITCHED: array(PERIODS) of linctr
	INCMAXDISCHARGE: array(PERIODS) of linctr
	INCMINCHARGE: array(PERIODS) of linctr
	INCMAXCHARGE: array(PERIODS) of linctr

	DECSWITCHEDBINARY: array(PERIODS) of linctr
	DECHASSWITCHED: array(PERIODS) of linctr
	DECMAXDISCHARGE: array(PERIODS) of linctr
	DECMINDISCHARGE: array(PERIODS) of linctr
	DECMAXCHARGE: array(PERIODS) of linctr

	INCRESRAMP: array(PERIODS,RESERVE) of linctr
	DECRESRAMP: array(PERIODS,RESERVE) of linctr
	STORAGEMAXDRAW: array(PERIODS) of linctr
	STORAGEMAXCHARGE: array(PERIODS) of linctr
	IMBALINCMAX: array(PERIODS,TRANCHES) of linctr
	IMBALDECMAX: array(PERIODS,TRANCHES) of linctr

	TOTALINCRES: array(PERIODS, RESERVE) of linctr
	TOTALDECRES: array(PERIODS, RESERVE) of linctr
	!RESMAX: array(PERIODS, RESERVE) of linctr - CS, converted to Bound

	GENSPILLLIMIT: array(PERIODS) of linctr
	MAXFUELDISCHARGE: array(PERIODS) of linctr
	PEAKIMPORTS: array(PERIODS) of linctr
	FIXRESERVE: array(PERIODS, RESERVE) of linctr
	FIXENERGYSCHEDULEBELOW: array(PERIODS) of linctr
	FIXENERGYSCHEDULEABOVE: array(PERIODS) of linctr
	MAXIMBALPURCHASES: array(PERIODS) of linctr
	MAXIMBALSALES: array(PERIODS) of linctr

	SELLBREAKERLIMIT: array(PERIODS) of linctr
	BUYBREAKERLIMIT: array(PERIODS) of linctr

	! CS
	GRIDCAPACITY: array(CAPACITYCHARGES,CAPCHARGEPERIODS) of linctr
	FIXGRIDCAP: array(CAPACITYCHARGES,CAPCHARGEPERIODS) of linctr !

	HIGHFLOWIN: array(PERIODS) of linctr
	HIGHFLOWOUT: array(PERIODS) of linctr
	BUYCAPLIMIT: array(PERIODS,CAPACITYCHARGES) of linctr
	SELLCAPLIMIT: array(PERIODS,CAPACITYCHARGES) of linctr

	! import and export volume limits
	IMPORTVOLUMEMATCH: array(IMPORTCHARGES) of linctr
	EXPORTVOLUMEMATCH: array(EXPORTCHARGES) of linctr

	! CS: define logical constraints
	LOWERFULL, UPPEREMPTY : array(CAPACITYCHARGES) of logctr !
	IMPORTUPPEREMPTY, IMPORTLOWERFULL: array(IMPORTCHARGES) of logctr
	EXPORTUPPEREMPTY, EXPORTLOWERFULL: array(EXPORTCHARGES) of logctr

	! import export volume charging
	EXPFLOWIN: linctr
	EXPFLOWOUT: linctr

	! to apply minimum charging/discharging constraints
	RESMAXCHARGE: array(PERIODS) of linctr
	RESMAXDISCHARGE: array(PERIODS) of linctr

	MINRESCHARGE: array(PERIODS,RESERVE) of linctr
	MINRESDISCHARGE: array(PERIODS,RESERVE) of linctr

	RESMINCHARGE: array(PERIODS) of logctr
	RESMINDISCHARGE: array(PERIODS) of logctr

	RESCOMMITBINARY: array(PERIODS,RESERVE) of linctr
	RESMINCHARGEAPPLIESBINARY: array(PERIODS) of linctr
	RESMINDISCHARGEAPPLIESBINARY: array(PERIODS) of linctr
	RESMINCHARGEAPPLIES: array(PERIODS,RESERVE) of linctr
	RESMINDISCHARGEAPPLIES: array(PERIODS,RESERVE) of linctr

	infeasVar: set of mpvar
	infeasConstr: set of linctr
end-declarations


declarations
	STORAGEBALANCEMIN: array(PERIODS) of linctr
	STORAGEBALANCEMINBOUND: array(PERIODS) of linctr
	STORAGEBALANCEMAX: array(PERIODS) of linctr
	STORAGEBALANCEMAXBOUND: array(PERIODS) of linctr

	storageBalMin: array(PERIODS) of mpvar
	storageBalMax: array(PERIODS) of mpvar
end-declarations

!-------------------------------------------------------------------------------------
! do initial preprocessing

! do initial calculations based on the input data
if allowArbitrage < 3 then
	initialStorage := initialStorage*capacity
else
	! if no arbitrage is allowed then the battery cannot start empty without preventing it from offering some services
	! hard-code to start half-full for now, but might need to revise later?
	initialStorage := 0.5*capacity
end-if

if allowArbitrage = 2 then
	storageCost := PENALTY/100
else
	storageCost := 0
end-if

initialCharging := 0
initialDischarging := 0

! calculate the reserve periods
forall(r in RESERVE, p in PERIODS) do
	case resSellPeriod(r) of
		1: resPeriod(p,r) := p
		2: resPeriod(p,r) := dayID(p)
		3: resPeriod(p,r) := weekID(p)
		4: resPeriod(p,r) := monthID(p)
		5: resPeriod(p,r) := 1
		6: do
			resPeriod(p,r) := customReservePeriod(dayID(p),r)
			if resPeriod(p,r) = 0 then resApplies(p,r) := false; end-if
		end-do
	end-case

	nResPeriods(r) := maxlist(nResPeriods(r),resPeriod(p,r))
end-do

! set up the charge and discharge cost
forall(p in PERIODS) do
	chargeCost(p) := chargeFuelPrice(p) * chargeFuelConsumption(p)
	dischargeCost(p) := dischargeFuelPrice(p) * dischargeFuelConsumption(p)
end-do

! apply a small penalty to buying power to discourage circular flows
forall(p in PERIODS | buyPrice(p) = sellPrice(p)) buyPrice(p) := buyPrice(p) * 1.001

! if generation is negative then turn it into demand, and vice versa
forall(p in PERIODS | generation(p) < 0) do
	demand(p) := demand(p) - generation(p)
	generation(p) := 0
end-do

forall(p in PERIODS | demand(p) < 0) do
	generation(p) := generation(p) - demand(p)
	demand(p) := 0
end-do

!------------------------------------------------------------------------------------
! loop over each block and optimiser it

nBlocks := ceil(nPeriods/blockSize)
blockStart := 1
blockEnd := minlist(blockSize,nPeriods)
blockRunOutEnd := minlist(blockSize+runOutPeriods,nPeriods)

totalImportsToNow := 0
totalExportsToNow := 0

forall(b in 1..nBlocks) do
	! clear any constraints which currently exist
	!clearConstraints

	with mpproblem do
		! set some optimiser parameters
		setparam("XPRS_VERBOSE",true)
		setparam("XPRS_MIPRELSTOP",relTol)
		setparam("XPRS_MIPABSSTOP",absTol)
		! temporary to debug
		setparam("XPRS_MAXTIME",maxTime)

		! CS: new definition for OPTPERIODS
		OPTPERIODS := blockStart..blockRunOutEnd
		! CS: range of periods that are saved at the end of the block (excludes run-out periods)
		SAVEDPERIODS := blockStart..blockEnd

		! temporary - add charge limit
		! sum(p in PERIODS) charging(p) <= 750*4

		! recalculate the distribution of imbalances using the linear forecasting data
		setupImbalForecast

		! CS: make the problem aware of the FIXRESERVE constraint
		forall(r in RESERVE, p in SAVEDPERIODS | resApplies(p,r)) do
			FIXRESERVE(resPeriod(p,r),r)
		end-do

		! make problem aware of the FIXENERGYSCHEDULECONSTRAINT
		if tradingHorizon > 0 then
			forall(p in blockStart..minlist(nPeriods,blockStart+tradingHorizon-1)) do
				FIXENERGYSCHEDULEBELOW(p)
				FIXENERGYSCHEDULEABOVE(p)
			end-do
		end-if

		! apply some constraints to the reserve volumes
		! constrain all sales to be <= the maximum that can be provided
		! CS : changed to a bound
		forall(r in RESERVE, p in 1..nResPeriods(r)) do
			RESCOMMITBINARY(p,r) := reserveCommit(p,r) is_binary
			soldRes(p,r) <= maxReserve(r)*reserveCommit(p,r)
		end-do

		! generate new constraints
		! CS - changed first two args for OPTPERIODS
		generateConstraints(OPTPERIODS,initialStorage,initialCharging,initialDischarging,b)

		! write out the current start and end period
		writeln('Period start:',blockStart)
		writeln('Period end:',blockEnd)
		writeln('Period run out end:',blockRunOutEnd)

		!stored(1000) = 0.1
		!forall(p in PERIODS) soldRes(p,1) = 4.5
		!OBJECTIVE <= 10000

		! do the optimisation
		maximise(OBJECTIVE)

		if getprobstat = XPRS_INF then
			exportprob(EP_MAX,outputDir+'\prob' + blockStart + '.lp',OBJECTIVE)
			getiis(infeasVar,infeasConstr)
			exit(1)
		end-if

		! fix the reserve sales etc within the window just optimised
		! CS - changed to remove impact of offset
		initialStorage := stored(blockEnd).sol
		initialCharging := charging(blockEnd).sol
		initialDischarging := discharging(blockEnd).sol

		! CS: Fix reserve that has been set in this block
		forall(r in RESERVE, p in SAVEDPERIODS | resApplies(p,r)) do
			FIXRESERVE(resPeriod(p,r),r) := soldRes(resPeriod(p,r),r) = soldRes(resPeriod(p,r),r).sol
		end-do

		forall(c in CAPACITYCHARGES, q in CAPCHARGEPERIODS) FIXGRIDCAP(c,q) := lowerCapacity(c,q) + upperCapacity(c,q) >= GRIDCAPACITY(c,q).sol !| q <= capChargeApplies(blockEnd,c)

		! if we are working with imbalance forecasts, then fix the energy market schedule
		! in the first hours of the next block so that the optimiser can't just net out all
		! imbalances against the energy market
		if blockEnd+1 < nPeriods and tradingHorizon > 0 then
			forall(p in (blockEnd+1)..minlist(nPeriods,blockEnd+tradingHorizon)) do
				FIXENERGYSCHEDULEBELOW(p) := purchase(p) - sell(p) >= purchase(p).sol - sell(p).sol - 0.001
				FIXENERGYSCHEDULEABOVE(p) := purchase(p) - sell(p) <= purchase(p).sol - sell(p).sol + 0.001
			end-do
		end-if

		! stop further adjustments for the next hours
		! update the total adjustment to the imbalance schedule
		if allowImbalanceAdjustment then
			forall(p in OPTPERIODS) totalImbalSales(p) := totalImbalSales(p) + sum(t in TRANCHES) (imbalanceSales(p,t).sol - imbalancePurchases(p,t).sol)
		end-if

		! store the results for writing out later
		writeResults(SAVEDPERIODS)

		! update the period being optimised
		blockStart := blockEnd + 1
		blockEnd := minlist(blockStart + blockSize - 1, nPeriods)
		blockRunOutEnd := minlist(blockEnd + runOutPeriods, nPeriods)
	end-do
end-do

!-------------------------------------------------------------------------------------
! generate the constraints on the optimisation problem
! CS: 	first two args replaced by OPTPERIODS
!		no offsets used in period variables
!		RUNPERIODS range no longer needed
!		OBJECTIVE modified for grid charging

procedure generateConstraints(OPTPERIODS: range, initStorage: real, initCharge: real, initDischarge: real, subProb:integer)
	declarations
		C1,C2: linctr ! auxiliary constraint
	end-declarations

	! calculate expected volumes in and out	to capture the impact of balancing and imbalances on the charging
	! the current formulas are simplifications of the full case
	forall(p in OPTPERIODS) do
		EXPFLOW(p) := sell(p) - purchase(p) - sum(r in RESERVE) decBalEnergy(r)*(decResCharge(p,r) + decResDischarge(p,r)) +
					  sum(r in RESERVE) incBalEnergy(r)*(incResCharge(p,r) + incResDischarge(p,r)) -
					  !sum(t in TRANCHES) imbalDecProb(p,t)*(imbalDecSize(p,t) - decImbalCharge(p,t) - decImbalDischarge(p,t)) -
					  !sum(t in TRANCHES) imbalIncProb(p,t)*(imbalIncSize(p,t) - incImbalCharge(p,t) - incImbalDischarge(p,t)) -
					  sum(t in TRANCHES) imbalDecProb(p,t)*(decImbalCharge(p,t) + decImbalDischarge(p,t)) +
					  sum(t in TRANCHES) imbalIncProb(p,t)*(incImbalCharge(p,t) + incImbalDischarge(p,t)) -
					  sum(t in TRANCHES) (totalImbalSales(p) + imbalanceSales(p,t) - imbalancePurchases(p,t))

		EXPEXPORT(p) := exportVolume(p) - importVolume(p) = EXPFLOW(p)
		!EXPIMPORT(p) := importVolume(p) >= -EXPFLOW(p)

		! only one dir
		!EXPFLOWONEDIR(p) := isExpImporting(p) is_binary
		!EXPEXPORTBINARY(p) := exportVolume(p) <= (1-isExpImporting(p)) * maxSell
		!EXPIMPORTBINARY(p) := importVolume(p) <= isExpImporting(p) * maxBuy
	end-do

	! CS: limit the gridCapacity variable
	if nCapacityCharges > 0 then
		if subProb>1 then
			forall(c in CAPACITYCHARGES, q in CAPCHARGEPERIODS) FIXGRIDCAP(c,q)
		end-if

		forall(c in CAPACITYCHARGES, q in CAPCHARGEPERIODS) do
			GRIDCAPACITY(c,q) := lowerCapacity(c,q) + upperCapacity(c,q)

			isFull(c,q) is_binary

			lowerCapacity(c,q) <= capBreakpoint(c)

			! set up auxiliary constraints
			C1 := upperCapacity(c,q) <= 0
			C2 := lowerCapacity(c,q) >= capBreakpoint(c)

			! build logical constraints for capacity breakpoint
			UPPEREMPTY(c) := indicator(-1,isFull(c,q),C1)
			LOWERFULL(c) := indicator(1,isFull(c,q),C2)

			! clear auxiliary constraints
			C1 := 0
			C2 := 0
		end-do
	end-if



	! apply the import charges
	if nImportCharges > 0 then
		forall(c in IMPORTCHARGES) do
			! force total imports to match lower and upper volumes
			IMPORTVOLUMEMATCH(c) := sum(p in OPTPERIODS | importChargeApplies(p,c)) importVolume(p) = lowerImportVol(c) + upperImportVol(c) !+ totalImportsToNow

			if totalImportsToNow > importBreakpoint(c) then
				! force the usage of the lower variable to be at maximum
				lowerImportVol(c) = 0

				! clear other constraints
				IMPORTUPPEREMPTY(c) := 0
				IMPORTLOWERFULL(c) := 0
			else
				! construct constraints to track both variables
				importIsFull(c) is_binary
				lowerImportVol(c) <= importBreakpoint(c) - totalImportsToNow

				! set up auxiliary constraints
				C1 := upperImportVol(c) <= 0
				C2 := lowerImportVol(c) >= importBreakpoint(c) - totalImportsToNow

				! build logical constraints for volume breakpoint
				IMPORTUPPEREMPTY(c) := indicator(-1,importIsFull(c),C1)
				IMPORTLOWERFULL(c) := indicator(1,importIsFull(c),C2)

				! clear auxiliary constraints
				C1 := 0
				C2 := 0
			end-if
		end-do
	end-if

	! apply the export charges
	if nExportCharges > 0 then
		forall(c in EXPORTCHARGES) do
			! force total imports to match lower and upper volumes
			EXPORTVOLUMEMATCH(c) := sum(p in OPTPERIODS | exportChargeApplies(p,c)) exportVolume(p) = lowerExportVol(c) + upperExportVol(c) !+ totalImportsToNow

			if totalExportsToNow > exportBreakpoint(c) then
				! force the usage of the lower variable to be at maximum
				lowerExportVol(c) = 0

				! clear other constraints
				EXPORTUPPEREMPTY(c) := 0
				EXPORTLOWERFULL(c) := 0
			else
				! construct constraints to track both variables
				exportIsFull(c) is_binary
				lowerExportVol(c) <= exportBreakpoint(c) - totalExportsToNow

				! set up auxiliary constraints
				C1 := upperExportVol(c) <= 0
				C2 := lowerExportVol(c) >= exportBreakpoint(c) - totalExportsToNow

				! build logical constraints for volume breakpoint
				EXPORTUPPEREMPTY(c) := indicator(-1,exportIsFull(c),C1)
				EXPORTLOWERFULL(c) := indicator(1,exportIsFull(c),C2)

				! clear auxiliary constraints
				C1 := 0
				C2 := 0
			end-if
		end-do
	end-if

	! CS - now use OPTPERIODS directly without offsets
	forall(p in OPTPERIODS) do
		! formulate the energy balance constraint
		! energy bought and sold must match expected demand and generation
		ENERGYBALANCE(p) := if(takeDemandFromStorage,0,demand(p) - generation(p)) +
			if(allowGenCurtailment,generationSpill(p),0) + charging(p) - discharging(p) =
			purchase(p) - sell(p) + balanceBreakerBuy(p) - balanceBreakerSell(p)

		! NOTE:
		! I'm not sure they're necessary and they made problems with imbalances/balancing infeasible
		SELLBREAKERLIMIT(p) := balanceBreakerSell(p) <= isCharging(p) * maxlist(0,generation(p) - demand(p) - maxSell)
		BUYBREAKERLIMIT(p) := balanceBreakerBuy(p) <= (1 - isCharging(p)) * maxlist(0,demand(p) - generation(p) - maxBuy)

		! constrain flows into and out of the site to be within the connection limits
		HIGHFLOWIN(p) := purchase(p) - sell(p) + sum(r in RESERVE) (decResCharge(p,r) + decResDischarge(p,r)) +
							sum(t in TRANCHES) (imbalIncSize(p,t) - incImbalCharge(p,t) - incImbalDischarge(p,t)) +
							sum(t in TRANCHES) (totalImbalSales(p) + imbalanceSales(p,t) - imbalancePurchases(p,t))

		HIGHFLOWOUT(p) := sell(p) - purchase(p) + sum(r in RESERVE) (incResCharge(p,r) + incResDischarge(p,r)) +
							sum(t in TRANCHES) (imbalDecSize(p,t) - decImbalCharge(p,t) - decImbalDischarge(p,t)) -
							sum(t in TRANCHES) (totalImbalSales(p) + imbalanceSales(p,t) - imbalancePurchases(p,t))

		! CS: deal with cases with and without capacity charges
		if nCapacityCharges > 0 then
			! if the constraint is on the maximum then simply apply it for each period
			forall(c in CAPACITYCHARGES | capChargeApplies(p,c) > 0 and not capChargeAverage(c)) do
				BUYCAPLIMIT(p,c) := HIGHFLOWIN(p) <= GRIDCAPACITY(c,capChargeApplies(p,c))
				SELLCAPLIMIT(p,c) := HIGHFLOWOUT(p) <= GRIDCAPACITY(c,capChargeApplies(p,c))
			end-do
		end-if

		! CS: the capacity still needs to be limited by maxBuy and maxSell since
		! if they are different then the selected capacity could exceed one of them
		PURCHASELIMIT(p) := HIGHFLOWIN(p) <= maxBuy + buyBreaker(p)
		SELLLIMIT(p) := HIGHFLOWOUT(p) <= maxSell + sellBreaker(p)

		! constrain stored energy to be less than the storage capacity
		STORAGELIMIT(p) := stored(p) <= capacity

		! constrain charging and discharging to be within the operational range of the battery
		CHARGELIMIT(p) := charging(p) <= maxCharge(p) * isCharging(p)
		DISCHARGELIMIT(p) := discharging(p) <= maxDischarge(p) * (1 - isCharging(p))
		ISCHARGINGBINARY(p) := isCharging(p) is_binary

		! constrain to only import or export but not both
		ISIMPORTING(p) := isImporting(p) is_binary
		IMPORTLIMIT(p) := purchase(p) <= isImporting(p) * maxBuy
		EXPORTLIMIT(p) := sell(p) <= (1-isImporting(p)) * maxSell

		! calculate the amount in store, including the expected impact of reserve and balancing actions
		STORAGEBALANCE(p) := stored(p) = if(p>getfirst(OPTPERIODS),stored(p-1),initStorage) * storageEff(p)^periodLength +
			chargeEff(p)*periodLength*charging(p) - periodLength*discharging(p)/dischargeEff(p)	+
			periodLength*chargeEff(p)*sum(r in RESERVE) (decResCharge(p,r)*decBalEnergy(r) - incResCharge(p,r)*incBalEnergy(r)) -
			periodLength/dischargeEff(p)*sum(r in RESERVE) (incResDischarge(p,r)*incBalEnergy(r) - decResDischarge(p,r)*decBalEnergy(r)) +
			periodLength*chargeEff(p)*sum(t in TRANCHES) (decImbalCharge(p,t)*imbalDecProb(p,t)  - incImbalCharge(p,t)*imbalIncProb(p,t)) -
			periodLength/dischargeEff(p)*sum(t in TRANCHES) (incImbalDischarge(p,t)*imbalIncProb(p,t) - decImbalDischarge(p,t)*imbalDecProb(p,t)) -
			if(allowFuelProduction,periodLength*fuelDischarge(p)/fuelConversionFactor(p),0) -
			if(takeDemandFromStorage,demand(p),0)

		! if arbitrage is not allowed then force the amount in storage to remain constant
		if allowArbitrage = 3 then
			STOPARBITRAGE(p) := stored(p) = if(p>getfirst(OPTPERIODS),stored(p-1),initStorage)
		end-if

		! apply run-up and run-down rates for the period as a whole
		! first split into upwards and downwards movements
		CHARGINGRAMP(p) := charging(p) = if(p>getfirst(OPTPERIODS),charging(p-1),initCharge) + chargeInc(p) - chargeDec(p)
		DISCHARGINGRAMP(p) := discharging(p) = if(p>getfirst(OPTPERIODS),discharging(p-1),initDischarge) + dischargeInc(p) - dischargeDec(p)

		! now ensure that the set of all movements can take place within the time period
		STORAGERAMP(p) := chargeInc(p)/chargeRamp(p) + chargeDec(p)/chargeRDR(p) +
						dischargeInc(p)/dischargeRamp(p) +	dischargeDec(p)/dischargeRDR(p) <= 60*periodLength

		! apply a limit to how much generation can be spilled
		if allowGenCurtailment then
			GENSPILLLIMIT(p) := generationSpill(p) <= maxlist(0,generation(p))
		end-if

		! limit the amount of fuel that can be discharged
		MAXFUELDISCHARGE(p) := fuelDischarge(p) <= maxFuelProduction(p)

		if balanceLossMethod = 1 then
			! make binary variables that keep track of whether if all incs/decs are called switching from
			! charging to discharging is required or not
			INCSWITCHEDBINARY(p) := incSwitched(p) is_binary
			DECSWITCHEDBINARY(p) := decSwitched(p) is_binary

			! make sure that incSwitched and decSwitched are consistent with what the storage is currently doing
			INCHASSWITCHED(p) := incSwitched(p) <= isCharging(p)
			DECHASSWITCHED(p) := decSwitched(p) <= 1 - isCharging(p)

			! the sum of all reductions to (dis)charging must be less than or equal to the amount that was
			! planned before balancing and imbalance calls
			INCMAXCHARGE(p) := sum(r in RESERVE) incResCharge(p,r) + sum(t in TRANCHES) incImbalCharge(p,t) <= charging(p)
			DECMAXDISCHARGE(p) := sum(r in RESERVE) decResDischarge(p,r) + sum(t in TRANCHES) decImbalDischarge(p,t) <= discharging(p)

			! if a switched between charging and discharging has occurred then the total amount change
			! must be equal to the total planned (dis-)charge before
			INCMINCHARGE(p) := sum(r in RESERVE) incResCharge(p,r) + sum(t in TRANCHES) incImbalCharge(p,t) >= charging(p) - (1-incSwitched(p))*maxCharge(p)
			DECMINDISCHARGE(p) := sum(r in RESERVE) decResDischarge(p,r) + sum(t in TRANCHES) decImbalDischarge(p,t) >= discharging(p) - (1-decSwitched(p))*maxDischarge(p)

			! the volume after the switch must not use more than the available space because the current volume and the maximum charge/discharge
			INCMAXDISCHARGE(p) := sum(r in RESERVE) incResDischarge(p,r) + sum(t in TRANCHES) incImbalDischarge(p,t) <= (1 - isCharging(p) + incSwitched(p)) * maxDischarge(p) - discharging(p)
			DECMAXCHARGE(p) := sum(r in RESERVE) decResCharge(p,r) + sum(t in TRANCHES) decImbalCharge(p,t) >= (isCharging(p) + decSwitched(p)) * maxCharge(p) - charging(p)
		elif balanceLossMethod = 2 then
			! only use incResDischarge, decResCharge, incImbalDischarge and decImbalCharge
			! others must be zero
			! this calculates losses from balancing and imbalances which are correct when the storage is at rest
			! for other situations it overestimates the losses, although this may be better than underestimation
			INCHASSWITCHED(p) := sum(r in RESERVE) incResCharge(p,r) + sum(t in TRANCHES) incImbalCharge(p,t) = 0
			DECHASSWITCHED(p) := sum(r in RESERVE) decResDischarge(p,r) + sum(t in TRANCHES) decImbalDischarge(p,t) = 0

			INCMAXDISCHARGE(p) := sum(r in RESERVE) incResDischarge(p,r) + sum(t in TRANCHES) incImbalDischarge(p,t) <=
									charging(p) + maxDischarge(p) - discharging(p)
			DECMAXCHARGE(p) := sum(r in RESERVE) decResCharge(p,r) + sum(t in TRANCHES) decImbalCharge(p,t) <=
									maxCharge(p) - charging(p) + discharging(p)
		end-if

		! make sure that reserve limits are respected
		RESMINCHARGE(p) := indicator(1,minChargeApplies(p),charging(p) - sum(r in RESERVE) (incResDischarge(p,r) + incResCharge(p,r)) >= minCharge(p))
		RESMINDISCHARGE(p) := indicator(1,minDischargeApplies(p),discharging(p) - sum(r in RESERVE) (decResDischarge(p,r) + decResCharge(p,r)) >= minDischarge(p))

		! imbal volumes are less than or equal to the tranche size
		if allowImbalanceAdjustment then
			forall(t in TRANCHES) do
				create(imbalancePurchases(p,t))
				create(imbalanceSales(p,t))
			end-do

			MAXIMBALPURCHASES(p) := sum(t in TRANCHES) imbalancePurchases(p,t) <= maxImbalPurchases(p)
			MAXIMBALSALES(p) := sum(t in TRANCHES) imbalanceSales(p,t) <= maxImbalSales(p)
		end-if

		forall(t in TRANCHES) IMBALINCMAX(p,t) := incImbalCharge(p,t) + incImbalDischarge(p,t) + imbalancePurchases(p,t) <= imbalIncSize(p,t)
		forall(t in TRANCHES) IMBALDECMAX(p,t) := decImbalCharge(p,t) + decImbalDischarge(p,t) + imbalanceSales(p,t) <= imbalDecSize(p,t)

		! total reserve volumes are equal to the amount sold, which is less than the maximum sold
		forall(r in RESERVE | resApplies(p,r)) do
			! now constrain to be equal to the sold volume
			if resSymmetrical(r) <> 3 then
				TOTALINCRES(p,r) := soldRes(resPeriod(p,r),r) = incResDischarge(p,r) + incResCharge(p,r)
			else
				TOTALINCRES(p,r) := incResDischarge(p,r) + incResCharge(p,r) = 0
			end-if

			if resSymmetrical(r) <> 2 then
				TOTALDECRES(p,r) := soldRes(resPeriod(p,r),r) = decResDischarge(p,r) + decResCharge(p,r)
			else
				TOTALDECRES(p,r) := decResDischarge(p,r) + decResCharge(p,r) = 0
			end-if
		end-do

		forall(r in RESERVE | not resApplies(p,r)) do
			TOTALINCRES(p,r) := incResDischarge(p,r) + incResCharge(p,r) = 0
			TOTALDECRES(p,r) := decResDischarge(p,r) + decResCharge(p,r) = 0
		end-do

		! calculate the minimum charging / discharging
		RESMINCHARGEAPPLIESBINARY(p) := minChargeApplies(p) is_binary
		RESMINDISCHARGEAPPLIESBINARY(p) := minDischargeApplies(p) is_binary

		forall(r in RESERVE | resApplies(p,r)) do
			MINRESCHARGE(p,r) := minCharge(p) >= reserveCommit(resPeriod(p,r),r)*resMinCharge(r)
			MINRESDISCHARGE(p,r) := minDischarge(p) >= reserveCommit(resPeriod(p,r),r)*resMinDischarge(r)

			if resMinCharge(r) > 0 then
				RESMINCHARGEAPPLIES(p,r) := minChargeApplies(p) >= reserveCommit(resPeriod(p,r),r)
			end-if

			if resMinDischarge(r) > 0 then
				RESMINDISCHARGEAPPLIES(p,r) := minDischargeApplies(p) >= reserveCommit(resPeriod(p,r),r)
			end-if
		end-do

		! apply constraints to ensure that it is possible to meet both inc and dec ramping / run-down on the specified timescales
		if balanceLossMethod = 1 then
			forall(s in RESERVE) do
				DECRESRAMP(p,s) := sum(r in RESERVE | r <= s) decResDischarge(p,r)/dischargeRDR(p) +
								   sum(r in RESERVE | r <= s) decResCharge(p,r)/chargeRamp(p) <=
								   resTimescales(s) / 60

				INCRESRAMP(p,s) := sum(r in RESERVE | r <= s) incResDischarge(p,r)/dischargeRamp(p) +
								   sum(r in RESERVE | r <= s) incResCharge(p,r)/chargeRDR(p) <=
								   resTimescales(s) / 60
			end-do
		else
			! if the response to balancing calls is not accurately split into charging and discharging then
			! we use the worse case ramping / run-down rate to ensure that whatever the storage is doing it is
			! possible to supply the reserve

			! NOTE: THIS SHOULD FACTOR IN ENERGY MARKET SCHEDULE / IMBALANCES???

			forall(s in RESERVE) do
				DECRESRAMP(p,s) := sum(r in RESERVE | r <= s) decResCharge(p,r)/minlist(chargeRamp(p),dischargeRDR(p)) <=
								   resTimescales(s) / 60

				INCRESRAMP(p,s) := sum(r in RESERVE | r <= s) incResDischarge(p,r)/minlist(dischargeRamp(p),chargeRDR(p)) <=
								   resTimescales(s) / 60
			end-do
		end-if

		! ensure that if the maximum calls occur the storage doesn't run out of energy
		STORAGEMAXDRAW(p) := if(p = blockStart,initialStorage,stored(p-1)) * storageEff(p)^periodLength +
			chargeEff(p)*periodLength*charging(p) - periodLength*discharging(p)/dischargeEff(p)	-
			chargeEff(p)*sum(r in RESERVE) resWorstCaseCall(r)*incResCharge(p,r) -
			1/dischargeEff(p)*sum(r in RESERVE) resWorstCaseCall(r)*incResDischarge(p,r) -
			incImbalCallLength*chargeEff(p)*sum(t in TRANCHES) incImbalCharge(p,t) -
			incImbalCallLength/dischargeEff(p)*sum(t in TRANCHES) incImbalDischarge(p,t) -
			if(allowFuelProduction,periodLength*fuelDischarge(p)/fuelConversionFactor(p),0)  -
			if(takeDemandFromStorage,demand(p),0) >= minPower*minPowerDuration

		STORAGEMAXCHARGE(p) := if(p = blockStart,initialStorage,stored(p-1)) * storageEff(p)^periodLength +
			chargeEff(p)*periodLength*charging(p) - periodLength*discharging(p)/dischargeEff(p)	+
			chargeEff(p)*sum(r in RESERVE) resWorstCaseCall(r)*decResCharge(p,r) +
			1/dischargeEff(p)*sum(r in RESERVE) resWorstCaseCall(r)*decResDischarge(p,r) +
			decImbalCallLength*chargeEff(p)*sum(t in TRANCHES) decImbalCharge(p,t) +
			decImbalCallLength/dischargeEff(p)*sum(t in TRANCHES) decImbalDischarge(p,t) -
			if(allowFuelProduction,periodLength*fuelDischarge(p)/fuelConversionFactor(p),0)  -
			if(takeDemandFromStorage,demand(p),0) <= capacity
	end-do

	! need to ensure that periods that will be fixed in the next optimisation are feasible even if imbalance volumes
	! change
	forall(p in OPTPERIODS | p > blockEnd and p - blockEnd <= tradingHorizon) do
		STORAGEBALANCEMIN(p) := storageBalMin(p) = if(p = blockEnd + 1,stored(p-1),storageBalMin(p-1)) * storageEff(p)^periodLength  +
			chargeEff(p)*periodLength*charging(p) - periodLength*discharging(p)/dischargeEff(p)	-
			periodLength*chargeEff(p)*sum(r in RESERVE) incResCharge(p,r) -
			periodLength/dischargeEff(p)*sum(r in RESERVE) incResDischarge(p,r) -
			incImbalCallLength*chargeEff(p)*sum(t in TRANCHES) incImbalCharge(p,t) -
			incImbalCallLength/dischargeEff(p)*sum(t in TRANCHES) incImbalDischarge(p,t) -
			if(allowFuelProduction,periodLength*fuelDischarge(p)/fuelConversionFactor(p),0)

		STORAGEBALANCEMINBOUND(p) := storageBalMin(p) >= minPower*minPowerDuration

		STORAGEBALANCEMAX(p) := storageBalMax(p) = if(p = blockEnd + 1,stored(p-1),storageBalMax(p-1)) * storageEff(p)^periodLength  +
			chargeEff(p)*periodLength*charging(p) - periodLength*discharging(p)/dischargeEff(p)	+
			periodLength*chargeEff(p)*sum(r in RESERVE) decResCharge(p,r) +
			periodLength/dischargeEff(p)*sum(r in RESERVE) decResDischarge(p,r) +
			decImbalCallLength*chargeEff(p)*sum(t in TRANCHES) decImbalCharge(p,t) +
			decImbalCallLength/dischargeEff(p)*sum(t in TRANCHES) decImbalDischarge(p,t) -
			if(allowFuelProduction,periodLength*fuelDischarge(p)/fuelConversionFactor(p),0)

		STORAGEBALANCEMAXBOUND(p) := storageBalMax(p) <= capacity
	end-do

	! if the constraint is on the average capacity usage then make sure that the average is less than the booked capacity
	! this functionality is mainly to cover triads (charges based on average consumption in 3 highest load points of the year
	! this needs to be formulated outside of the main loop after all HIGHFLOWIN and HIGHFLOWOUT have been created

	! MIGHT NEED REFORMULATING BECAUSE AVERAGE WILL INCLUDE CAPACITY THAT MIGHT BE USED TO RESERVE/BALANCING
	! THIS WILL PROBABLY PRODUCE AN OVERESTIMATE - I THINK TRIADS IGNORE CAPACITY THAT IS POTENTIALLY NEEDED BUT NOT
	! USED
	if nCapacityCharges > 0 then
		forall(c in CAPACITYCHARGES, cp in CAPCHARGEPERIODS | capChargeAverage(c) and sum(q in OPTPERIODS) integer(capChargeApplies(q,c) = cp) > 0) do
			BUYCAPLIMIT(cp,c) := (sum(q in OPTPERIODS | capChargeApplies(q,c) > 0) HIGHFLOWIN(q)) /
					                    (sum(q in PERIODS) capChargeApplies(q,c)) <= GRIDCAPACITY(c,cp)

			SELLCAPLIMIT(cp,c) := (sum(q in OPTPERIODS | capChargeApplies(q,c) > 0) HIGHFLOWOUT(q)) /
					                    (sum(q in PERIODS) capChargeApplies(q,c)) <= GRIDCAPACITY(c,cp)
		end-do
	end-if

	OBJECTIVE := periodLength * sum(p in OPTPERIODS) (sell(p) * sellPrice(p) - purchase(p) * buyPrice(p)) -
			 ! penalties for breaking energy balance constraint
			 PENALTY * sum(p in OPTPERIODS) (balanceBreakerBuy(p) + balanceBreakerSell(p)) -
			 2 * PENALTY * sum(p in OPTPERIODS) (buyBreaker(p) + sellBreaker(p)) -
			 ! charging / discharging costs
			 periodLength*sum(p in OPTPERIODS) (charging(p) * chargeCost(p) + discharging(p) * dischargeCost(p)) -
		  	 periodLength*sum(p in OPTPERIODS, r in RESERVE) (decResCharge(p,r)*decBalEnergy(r) - incResCharge(p,r)*incBalEnergy(r)) * chargeCost(p) -
		 	 periodLength*sum(p in OPTPERIODS, r in RESERVE) (incResDischarge(p,r)*incBalEnergy(r) - decResDischarge(p,r)*decBalEnergy(r)) * dischargeCost(p) -
			 periodLength*sum(p in OPTPERIODS, t in TRANCHES) (decImbalCharge(p,t)*imbalDecProb(p,t)  - incImbalCharge(p,t)*imbalIncProb(p,t)) * chargeCost(p) -
			 periodLength*sum(p in OPTPERIODS, t in TRANCHES) (incImbalDischarge(p,t)*imbalIncProb(p,t) - decImbalDischarge(p,t)*imbalDecProb(p,t)) * dischargeCost(p) +
			 ! income from selling reserve
			 sum(p in OPTPERIODS, r in RESERVE | resApplies(p,r)) resPrice(p,r) * periodLength * soldRes(resPeriod(p,r),r) +
			 ! income - charging / discharging costs from providing balancing services
			 periodLength*sum(p in OPTPERIODS, r in RESERVE | resApplies(p,r)) decBalPrice(p,r)*decBalEnergy(r)*if(resSymmetrical(r) <> 2,soldRes(resPeriod(p,r),r),0) +
			 periodLength*sum(p in OPTPERIODS, r in RESERVE | resApplies(p,r)) incBalPrice(p,r)*incBalEnergy(r)*if(resSymmetrical(r) <> 3,soldRes(resPeriod(p,r),r),0) -
			! income and costs of imbalances
			periodLength*sum(p in OPTPERIODS) imbalShortfallPrice(p)*sum(t in TRANCHES) imbalIncProb(p,t)*(imbalIncSize(p,t) - incImbalCharge(p,t) - incImbalDischarge(p,t) - imbalancePurchases(p,t)) +
			periodLength*sum(p in OPTPERIODS) imbalExcessPrice(p)*sum(t in TRANCHES) imbalDecProb(p,t)*(imbalDecSize(p,t) - decImbalCharge(p,t) - decImbalDischarge(p,t) - imbalanceSales(p,t)) -
			! penalise storage if necessary
			periodLength*storageCost*sum(p in OPTPERIODS)stored(p) +
			! add value of fuel
			periodLength*sum(p in OPTPERIODS | allowFuelProduction) fuelDischarge(p) * outputFuelPrice(p)

	! if we allow the optimiser to adjust the energy market position based on the imbalance distributions, then we need
	! to penalise incorrect guesses
	if allowImbalanceAdjustment then
		OBJECTIVE -= sum(p in OPTPERIODS, t in TRANCHES) imbalShortfallPrice(p)*imbalanceSales(p,t)*(1 - imbalDecProb(p,t))
		OBJECTIVE += sum(p in OPTPERIODS, t in TRANCHES) imbalExcessPrice(p)*imbalancePurchases(p,t)*(1 - imbalIncProb(p,t))

		OBJECTIVE += sum(p in OPTPERIODS, t in TRANCHES) sellPrice(p)*imbalanceSales(p,t)
		OBJECTIVE -= sum(p in OPTPERIODS, t in TRANCHES) buyPrice(p)*imbalancePurchases(p,t)
	end-if

	! CS: add extra terms to the objective if grid charging is applied
	if nCapacityCharges>0 then
		OBJECTIVE -= sum(c in CAPACITYCHARGES, q in CAPCHARGEPERIODS) (lowerCapCharge(c)*lowerCapacity(c,q)	+ 	upperCapCharge(c)*upperCapacity(c,q))
	end-if

	if nExportCharges > 0 then
		OBJECTIVE -= sum(c in EXPORTCHARGES) (lowerExportCharge(c)*lowerExportVol(c) + upperExportCharge(c)*upperExportVol(c))
	end-if

	if nImportCharges > 0 then
		OBJECTIVE -= sum(c in IMPORTCHARGES) (lowerImportCharge(c)*lowerImportVol(c) + upperImportCharge(c)*upperImportVol(c))
	end-if
end-procedure


!-------------------------------------------------------------------------------------
! write out results
! CS 	- two input args are replaced by SAVEDPERIODS
!		- offsets removed
!		- results arrays moved from global to local scope
!		- annualCapacity.out added

procedure writeResults(SAVEDPERIODS: range)
	declarations
		writeMode : integer

		currGenCharge: real
		currDemDischarge: real
		currPassThrough: real
		currGenSold: real
		currDemBought: real
		currSpilling: real

		curtailmentWithoutStorage: real
		curtailmentDecrease: real

		! imbalance outputs
		imbalStorage: array(PERIODS) of real
		imbalShortfallCost: array(PERIODS) of real
		imbalExcessIncome: array(PERIODS) of real
		imbalAvoidedCost: array(PERIODS) of real
		imbalLostIncome: array(PERIODS) of real
		imbalIncCoverage: array(PERIODS) of real
		imbalDecCoverage: array(PERIODS) of real
		imbalCost: array(PERIODS) of real

		! imbalance market outputs
		imbalTradeExcessChange: array(PERIODS) of real
		imbalTradeShortfallChange: array(PERIODS) of real

		! CS: grid capacity charges
		gridCapacityBooked: array(CAPCHARGEPERIODS,CAPACITYCHARGES) of real

		! expected flow across grid connection
		expFlow: array(PERIODS) of real
	end-declarations

	! set the write format to ensure higher precision of optimiser outputs
	setparam("REALFMT", "%1.3f")

	! CS: get the annual capacity charge
	if nCapacityCharges > 0 then
		if getlast(SAVEDPERIODS) = nPeriods then
			forall(c in CAPACITYCHARGES, q in CAPCHARGEPERIODS) gridCapacityBooked(q,c) := (lowerCapacity(c,q).sol	+ upperCapacity(c,q).sol)
			writeFile(outputDir + '\annualCapacity.out',gridCapacityBooked,F_OUTPUT)
		end-if
	else
		writeFile(outputDir + '\annualCapacity.out',0,F_OUTPUT)
	end-if

	! get the expected flow across the grid connection (+ve means export)
	forall(p in SAVEDPERIODS) expFlow(p) := EXPFLOW(p).sol

	! calculate output arrays
	if nImbalTranches + nResProducts > 0 then
		forall(p in SAVEDPERIODS) do
			! imbalance outputs
			imbalStorage(p) := 	periodLength*chargeEff(p)*sum(t in TRANCHES) (decImbalCharge(p,t).sol*imbalDecProb(p,t)  - incImbalCharge(p,t).sol*imbalIncProb(p,t)) -
				periodLength/dischargeEff(p)*sum(t in TRANCHES) (incImbalDischarge(p,t).sol*imbalIncProb(p,t) - decImbalDischarge(p,t).sol*imbalDecProb(p,t))

			imbalIncCoverage(p) := sum(t in TRANCHES) (incImbalDischarge(p,t).sol + incImbalCharge(p,t).sol)
			imbalDecCoverage(p) := sum(t in TRANCHES) (decImbalDischarge(p,t).sol + decImbalCharge(p,t).sol)

			imbalShortfallCost(p) := periodLength*imbalShortfallPrice(p)*sum(t in TRANCHES) imbalIncProb(p,t)*(imbalIncSize(p,t) - incImbalCharge(p,t).sol - incImbalDischarge(p,t).sol)
			imbalExcessIncome(p) := periodLength*imbalExcessPrice(p)*sum(t in TRANCHES) imbalDecProb(p,t)*(imbalDecSize(p,t) - decImbalCharge(p,t).sol - decImbalDischarge(p,t).sol)

			imbalAvoidedCost(p) := periodLength*imbalShortfallPrice(p)*sum(t in TRANCHES) imbalIncProb(p,t)*(incImbalCharge(p,t).sol + incImbalDischarge(p,t).sol)
			imbalLostIncome(p) := periodLength*imbalExcessPrice(p)*sum(t in TRANCHES) imbalDecProb(p,t)*(decImbalCharge(p,t).sol + decImbalDischarge(p,t).sol)

			imbalCost(p) := periodLength*sum(t in TRANCHES) (decImbalCharge(p,t).sol*imbalDecProb(p,t)  - incImbalCharge(p,t).sol*imbalIncProb(p,t)) * chargeCost(p) +
				 periodLength*sum(t in TRANCHES) (incImbalDischarge(p,t).sol*imbalIncProb(p,t) - decImbalDischarge(p,t).sol*imbalDecProb(p,t)) * dischargeCost(p)

			! reserve outputs
			forall(r in RESERVE | resApplies(p,r)) do
				resProvision(p,r) := soldRes(resPeriod(p,r),r).sol
				resIncome(p,r) := resProvision(p,r) * periodLength * resPrice(p,r)
			end-do

			! balancing outputs
			forall(r in RESERVE | resApplies(p,r)) do
				balStorage(p,r) := periodLength*chargeEff(p)*(decResCharge(p,r).sol*decBalEnergy(r) - incResCharge(p,r).sol*incBalEnergy(r)) -
				periodLength/dischargeEff(p)*(incResDischarge(p,r).sol*incBalEnergy(r) - decResDischarge(p,r).sol*decBalEnergy(r))

				balIncome(p,r) := periodLength*decBalPrice(p,r)*decBalEnergy(r)*if(resSymmetrical(r) <> 2,soldRes(resPeriod(p,r),r).sol,0) +
				periodLength*incBalPrice(p,r)*incBalEnergy(r)*if(resSymmetrical(r) <> 3,soldRes(resPeriod(p,r),r).sol,0)

				balCost(p,r) := periodLength*(decResCharge(p,r).sol*decBalEnergy(r) - incResCharge(p,r).sol*incBalEnergy(r)) * chargeCost(p) +
			 	 periodLength*(incResDischarge(p,r).sol*incBalEnergy(r) - decResDischarge(p,r).sol*decBalEnergy(r)) * dischargeCost(p)
			end-do
		end-do
	end-if

	! update the total exports and imports so far
	totalExportsToNow := totalExportsToNow + sum(p in SAVEDPERIODS) exportVolume(p).sol
	totalImportsToNow := totalImportsToNow + sum(p in SAVEDPERIODS) importVolume(p).sol

	! if startPeriod is 1 then delete the existing files
	if getfirst(SAVEDPERIODS) = 1 then
		writeMode := F_OUTPUT
	else
		writeMode := F_APPEND
	end-if

	! write out imbalance purchases and sales
	if allowImbalanceAdjustment then
		! calculate the improvement (or not!) from the trading strategy
		forall(p in SAVEDPERIODS) do
			imbalTradeExcessChange(p) := maxlist(0,-imbalanceActuals(p) - totalImbalSales(p)) - maxlist(0,-imbalanceActuals(p))
			imbalTradeShortfallChange(p) := maxlist(0,imbalanceActuals(p) + totalImbalSales(p)) - maxlist(0,imbalanceActuals(p))
		end-do

		! write out the data
		fopen(outputDir + '\imbalanceAdjustment.out',writeMode)
			forall(p in SAVEDPERIODS) writeln(totalImbalSales(p),' ',imbalTradeExcessChange(p),' ',imbalTradeShortfallChange(p),' ',imbalTradeExcessChange(p)*imbalExcessPrice(p) - imbalTradeShortfallChange(p)*imbalShortfallPrice(p),' ',
					if(totalImbalSales(p)>0,totalImbalSales(p)*sellPrice(p),totalImbalSales(p)*buyPrice(p)))
		fclose(writeMode)
	end-if

	! write out the result summary files
	fopen(outputDir + '\results.out',writeMode)
		forall(p in SAVEDPERIODS) do

			! calculate the amount that can actually be imported/exported due to site limits
			curtailmentWithoutStorage := maxlist(0,generation(p) - demand(p) - maxSell)
			currSpilling := generationSpill(p).sol + balanceBreakerSell(p).sol

			curtailmentDecrease := maxlist(0,curtailmentWithoutStorage - currSpilling)

			! calculate current charging from generation and discharging to meet demand and how
			! demand and generation flow through the site
			currGenCharge := (! periodLength* !) maxlist(0,minlist(charging(p).sol,generation(p) - currSpilling))

			if takeDemandFromStorage then
				currDemDischarge := demand(p)
			else
				currDemDischarge := (! periodLength* !) maxlist(0,minlist(discharging(p).sol,demand(p)))
			end-if

			currPassThrough := (! periodLength* !) maxlist(0,minlist(generation(p) - currSpilling - currGenCharge,demand(p) - currDemDischarge))
			currGenSold := (! periodLength* !) maxlist(0,generation(p) - currSpilling - currGenCharge - currPassThrough)
			currDemBought := (! periodLength* !) maxlist(0,demand(p) - currDemDischarge - currPassThrough)

			currGenCharge := currGenCharge - curtailmentDecrease !maxlist(0,currGenCharge - curtailmentDecrease)

			if demand(p) <> currDemBought + currDemDischarge then
				writeln('Error!')
			end-if

			! write out the data
			writeln(charging(p).sol,' ', ! amount charged
					discharging(p).sol,' ', ! amount discharged
					stored(p).sol,' ', ! amount in storage
					purchase(p).sol,' ', ! amount of power purchased
					sell(p).sol,' ', ! amount of power sold
					periodLength*currSpilling,' ', ! amount of generation spilled
					periodLength*curtailmentDecrease,' ', ! amount that generation spilling has been decreased by
					currGenSold,' ', ! amount of generation sold
					currPassThrough,' ', ! amount of generation that is used directly to meet demand
					currGenCharge,' ', ! the amount of generation stored
					currDemBought,' ', ! the amount of demand met by purchases from the market
					currDemDischarge,' ',  ! the amount of discharging that goes to meet demand
					expFlow(p)) ! the expected flow across the grid connection

		end-do
	fclose(writeMode)

	fopen(outputDir + '\imbalance.out',writeMode)
		forall(p in SAVEDPERIODS) do
			writeln(imbalIncCoverage(p),' ',imbalDecCoverage(p),' ',imbalStorage(p),' ',imbalShortfallCost(p),' ',imbalExcessIncome(p),' ',imbalAvoidedCost(p),' ',imbalLostIncome(p),' ',imbalCost(p))
		end-do
	fclose(writeMode)

	fopen(outputDir + '\fuelProduction.out',writeMode)
		forall(p in SAVEDPERIODS) writeln(fuelDischarge(p).sol,' ',outputFuelPrice(p)*fuelDischarge(p).sol)
	fclose(writeMode)

	! write out the reserve and balancing results
	if getlast(SAVEDPERIODS) = nPeriods then
		writeFile(outputDir + '\resProvision.out',resProvision,F_OUTPUT)
		writeFile(outputDir + '\resIncome.out',resIncome,F_OUTPUT)
		writeFile(outputDir + '\balStorage.out',balStorage,F_OUTPUT)
		writeFile(outputDir + '\balIncome.out',balIncome,F_OUTPUT)
		writeFile(outputDir + '\balCost.out',balCost,F_OUTPUT)
	end-if
end-procedure

!------------------------------------------------------------------------
! define a function to read data from the control.in file

procedure readControlFile
	fopen(inputDir + '\control.in',F_INPUT)
		readln
		readln(capacity)
		readln
		readln(onSiteGenPresent)
		readln
		readln(onSiteDemPresent)
		readln
		readln(allowGenCurtailment)
		readln
		readln(maxBuy)
		readln
		readln(maxSell)
		readln
		readln(minPower)
		readln
		readln(minPowerDuration)
		readln
		readln(allowFuelProduction)
		readln
		readln(nPeriods)
		readln
		readln(nImbalTranches)
		readln
		readln(maxImbalForecastHours)
		readln
		readln(nImbalForecastTranches)
		readln
		readln(imbalModelType)
		readln
		readln(allowImbalanceAdjustment)
		readln
		readln(tradingHorizon)
		readln
		readln(takeDemandFromStorage)
		readln
		readln(nResProducts)
		readln
		readln(blockSize)
		readln
		readln(runOutPeriods)
		readln
		readln(maxTime)
		readln
		readln(balanceLossMethod)
		readln
		readln(relTol)
		readln
		readln(absTol)
		readln
		readln(initialStorage)
		readln
		readln(allowArbitrage)
		readln
		readln(incImbalCallLength)
		readln
		readln(decImbalCallLength)
		readln
		readln(nCapacityCharges)
		readln
		readln(nImportCharges)
		readln
		readln(nExportCharges)
		readln
		readln(nCapChargePeriods)
	fclose(F_INPUT)

	if nPeriods = 8760 * 4 then
		periodLength := 0.25
	end-if
end-procedure

!------------------------------------------------------------------------
! define functions for reading data from files - 1d arrays

procedure readFile(filename:string, dest:array(p: range) of real)
	fopen(filename, F_INPUT)
		forall(a in p) readln(dest(a))
	fclose(F_INPUT)
end-procedure

procedure readFile(filename:string, dest:array(p: range) of integer)
	fopen(filename, F_INPUT)
		forall(a in p) readln(dest(a))
	fclose(F_INPUT)
end-procedure

procedure readFile(filename:string, dest:array(p: range) of boolean)
	fopen(filename, F_INPUT)
		forall(a in p) readln(dest(a))
	fclose(F_INPUT)
end-procedure

!procedure readFile(filename:string, dest:array(p: range) of string)
!	fopen(filename, F_INPUT)
!		forall(a in p) readln(dest(a))
!	fclose(F_INPUT)
!end-procedure



!------------------------------------------------------------------------
! define functions for reading data from files - 2d arrays

procedure readFile(filename:string, dest:array(p: range,q: range) of real)
	fopen(filename, F_INPUT)
		forall(a in p) do
			forall(b in q) do
				read(dest(a,b))
			end-do

			readln
		end-do
	fclose(F_INPUT)
end-procedure

procedure readFile(filename:string, dest:array(p: range,q: range) of boolean)
	fopen(filename, F_INPUT)
		forall(a in p) do
			forall(b in q) do
				read(dest(a,b))
			end-do

			readln
		end-do
	fclose(F_INPUT)
end-procedure

!------------------------------------------------------------------------
! define function for reading sparse data from arrays

procedure readSparseFile(filename:string, dest:array(p: range, q: range) of real)
	declarations
		header: string
		currVal : real
		a, b: real
		c: integer
		is2D: boolean
	end-declarations

	! first get the header row to check the format of the file
	fopen(filename, F_INPUT)
	read(header)

	! check that the array is sparse
	if header <> 'sparse' then
		! if not then use the non-sparse function
		fclose(F_INPUT)
		readFile(filename, dest)
	else
		! check whether the 2nd dimension is specified in the file or not
		readln(header)
		is2D := header = '2d'

		! while there is data in the file process it
		while (not iseof) do
			read(a,b)

			! there are two types of line - ones whose first element is zero specify a new value to write
			! otherwise the format is start_row end_row (optional column), specifying where to write the last
			! specified value
			if a = 0 then
				! update the value to write
				currVal := b
			else
				! write the current value into the specified column and range of rows
				if is2D then
					readln(c)
				else
					c := 1
				end-if

				forall(j in integer(a)..integer(b)) dest(j,c) := currVal
			end-if
		end-do

		fclose(F_INPUT)
	end-if
end-procedure

procedure readSparseFile(filename:string, dest:array(p: range, q: range) of integer)
	declarations
		dest2: array(p,q) of real
	end-declarations

	readSparseFile(filename,dest2)
	forall(i in p, j in q) dest(i,j) := integer(dest2(i,j))
end-procedure

procedure readSparseFile(filename:string, dest:array(p: range, q: range) of boolean)
	declarations
		dest2: array(p,q) of real
	end-declarations

	readSparseFile(filename,dest2)
	forall(i in p, j in q) dest(i,j) := dest2(i,j) <> 0
end-procedure

!------------------------------------------------------------------------
! define functions for reading sparse data from files - 1d arrays

procedure readSparseFile(filename:string, dest:array(p: range) of real)
	declarations
		dest2: array(p, 1..1) of real
	end-declarations

	readSparseFile(filename, dest2)
	forall(i in p) dest(i) := dest2(i, 1)
end-procedure

procedure readSparseFile(filename:string, dest:array(p: range) of integer)
	declarations
		dest2: array(p, 1..1) of integer
	end-declarations

	readSparseFile(filename, dest2)
	forall(i in p) dest(i) := dest2(i, 1)
end-procedure

procedure readSparseFile(filename:string, dest:array(p: range) of boolean)
	declarations
		dest2: array(p, 1..1) of boolean
	end-declarations

	readSparseFile(filename, dest2)
	forall(i in p) dest(i) := dest2(i, 1)
end-procedure

!------------------------------------------------------------------------
! define function for writing data to files

procedure writeFile(filename:string, source:array(p: range, q: range) of real, writeMode: integer)
	fopen(filename, writeMode)
		forall(a in p) do
			forall(b in q) write(source(a,b),' ')
			writeln
		end-do
	fclose(writeMode)
end-procedure

procedure writeFile(filename:string, source:array(p: range) of real, writeMode: integer)
	fopen(filename, writeMode)
		forall(a in p) writeln(source(a))
	fclose(writeMode)
end-procedure

! CS add single element version
procedure writeFile(filename:string, source:real, writeMode: integer)
	fopen(filename, writeMode)
		writeln(source)
	fclose(writeMode)
end-procedure

!-----------------------------------------------------------------------
! define procedures for setting up imbalances

procedure setupImbal_Forecast
	! this function takes the forecasting algorithm for imbalance volumes / prices and populates the following outputs:
	! - imbalIncSize, imbalDecSize - size of each tranche of the distribution in MW
	! - imbalIncProb, imbalDecProb - probability of each tranche being used (expected MWh/MW)
	! - imbalExcessPrice - expected price received for excess power if long
	! - imbalShortfallPrice - expected penalty price paid if short

	declarations
		initialImbal: real
		initialExcess: real
		initialShortfall: real

		currForecastTranche: integer
		currExcessTranche: integer
		currShortfallTranche: integer
		hoursAhead: integer
		currForecast: real

		trancheMin: real
		trancheMax: real
		currTrancheSize: real
	end-declarations

	! get the starting imbalance
	initialImbal := imbalanceActuals(blockStart)
	initialExcess := imbalExcessActual(blockStart)
	initialShortfall := imbalShortfallActual(blockStart)

	! identify which forecast tranche applies
	forall(t in IMBALFORECASTTRANCHES | imbalForBoundaries(t) <= initialImbal) currForecastTranche := t
	forall(t in IMBALFORECASTTRANCHES | imbalExcessTranches(t) <= initialExcess) currExcessTranche := t
	forall(t in IMBALFORECASTTRANCHES | imbalShortfallTranches(t) <= initialShortfall) currShortfallTranche := t

	! set up the inc and dec tranches for the first period
	imbalIncSize(blockStart,1) := maxlist(0,initialImbal + totalImbalSales(blockStart))
	imbalDecSize(blockStart,1) := maxlist(0,-initialImbal - totalImbalSales(blockStart))
	imbalExcessPrice(blockStart) := initialExcess
	imbalShortfallPrice(blockStart) := initialShortfall
	imbalIncProb(blockStart,1) := 1
	imbalDecProb(blockStart,1) := 1
	maxImbalSales(blockStart) := 0
	maxImbalPurchases(blockStart) := 0

	forall(t in TRANCHES | t > 1) do
		imbalIncSize(blockStart,t) := 0
		imbalDecSize(blockStart,t) := 0
		imbalIncProb(blockStart,t) := 0
		imbalDecProb(blockStart,t) := 0
	end-do

	! set up the inc and dec tranches for all the other periods
	forall(p in OPTPERIODS | p > blockStart) do
		! calculate the number of hours forecast ahead
		! after that horizon always use the same forecasting coefficients and
		! errors
		hoursAhead := minlist(p - blockStart,maxImbalForecastHours)

		! calculate the current forecast volume
		currForecast := imbalForCoeffs(hoursAhead,currForecastTranche) * initialImbal +
						imbalForConsts(hoursAhead,currForecastTranche)

		! adjust to take into account trading actions to reduce the expected imbalance
		currForecast := currForecast + totalImbalSales(p)

		! the maximum that can be traded out by the optimiser is the expected imbalance
		if hoursAhead >= tradingHorizon then
			maxImbalSales(p) := maxlist(0,-currForecast)
			maxImbalPurchases(p) := maxlist(0,currForecast)
		else
			maxImbalSales(p) := 0
			maxImbalPurchases(p) := 0
		end-if

		! set all the values to zero before assigning them new values
		forall(t in TRANCHES) do
			imbalIncSize(p,t) := 0
			imbalDecSize(p,t) := 0
			imbalIncProb(p,t) := 0
			imbalDecProb(p,t) := 0
		end-do

		! allocate the incremental imbalance tranches into the arrays used to build the
		! optimisation problem
		trancheMin := currForecast

		forall(t in 1..nImbalTranches) do
			! calculate the top of the tranche
			trancheMax := trancheMin + imbalForIncSize(hoursAhead)

			! because imbalance tranches start from the forecast value, some or
			! all of the inc tranche could actually be on the dec side
			! therefore split into two parts, an inc part and a dec part
			imbalDecSize(p, nImbalTranches - t + 1) := maxlist(0,minlist(0,trancheMax) - trancheMin)
			imbalDecProb(p, nImbalTranches - t + 1) := 1 - imbalForIncCallProb(hoursAhead,t)

			imbalIncSize(p, nImbalTranches + t) := maxlist(0,trancheMax - maxlist(0,trancheMin))
			imbalIncProb(p, nImbalTranches + t) := imbalForIncCallProb(hoursAhead,t)

			! update the tranche min
			trancheMin := trancheMax
		end-do

		! do the same for the decremental imbalance tranches
		trancheMax := currForecast

		forall(t in 1..nImbalTranches) do
			! calculate the top of the tranche
			trancheMin := trancheMax - imbalForDecSize(hoursAhead)

			! because imbalance tranches start from the forecast value, some or
			! all of the inc tranche could actually be on the dec side
			! therefore split into two parts, an inc part and a dec part
			imbalIncSize(p, nImbalTranches - t + 1) := maxlist(0,trancheMax - maxlist(0,trancheMin))
			imbalIncProb(p, nImbalTranches - t + 1) := 1 - imbalForDecCallProb(hoursAhead,t)

			imbalDecSize(p, nImbalTranches + t) := maxlist(0,minlist(0,trancheMax) - trancheMin)
			imbalDecProb(p, nImbalTranches + t) := imbalForDecCallProb(hoursAhead,t)

			! update the tranche min
			trancheMax := trancheMin
		end-do

		! now calculate the current excess price forecast
		imbalExcessPrice(p) := initialExcess * imbalExcessCoeffs(hoursAhead,currExcessTranche) + imbalExcessConsts(hoursAhead,currExcessTranche) ! imbalExcessActual(p) !
		imbalShortfallPrice(p) := initialShortfall * imbalShortfallCoeffs(hoursAhead,currShortfallTranche) + imbalShortfallConsts(hoursAhead,currShortfallTranche) ! imbalShortfallActual(p) !
	end-do
end-procedure

procedure setupImbal_Actuals
	! assume for this version that trading out is not allowed (e.g. maxImbalSales = maxImbalPurchases = 0)
	! otherwise with perfect foresight a massive overestimate of value will be produced

	forall(p in OPTPERIODS) do
		forall(t in TRANCHES) do
			imbalIncSize(p,t) := 0
			imbalDecSize(p,t) := 0
			imbalIncProb(p,t) := 0
			imbalDecProb(p,t) := 0
		end-do

		imbalIncSize(p,1) := maxlist(0,imbalanceActuals(p) + totalImbalSales(blockStart))
		imbalDecSize(p,1) := maxlist(0,-imbalanceActuals(p) - totalImbalSales(blockStart))
		imbalExcessPrice(p) := imbalExcessActual(p)
		imbalShortfallPrice(p) := imbalShortfallActual(p)
		imbalIncProb(p,1) := 1
		imbalDecProb(p,1) := 1
		maxImbalSales(p) := 0
		maxImbalPurchases(p) := 0
	end-do
end-procedure

procedure setupImbal_Dist
	! distribution is fixed for all time instead of being a function of the current imbalance

	! calculate volume weighted average shortfall and excess prices
	declarations
		volWeightExcessPrice: real
		totalExcessVol: real
		volWeightShortfallPrice: real
		totalShortfallVol: real
	end-declarations

	forall(p in PERIODS) do
		volWeightExcessPrice := volWeightExcessPrice + maxlist(0,-imbalanceActuals(p))*imbalExcessActual(p)
		totalExcessVol := totalExcessVol + maxlist(0,-imbalanceActuals(p))

		volWeightShortfallPrice := volWeightShortfallPrice + maxlist(0,imbalanceActuals(p))*imbalShortfallActual(p)
		totalShortfallVol := totalShortfallVol + maxlist(0,imbalanceActuals(p))
	end-do

	volWeightExcessPrice := if(totalExcessVol <> 0, volWeightExcessPrice / totalExcessVol, 0)
	volWeightShortfallPrice := if(totalShortfallVol <> 0, volWeightShortfallPrice / totalShortfallVol, 0)

	! populate arrays
	forall(p in PERIODS) do
		imbalExcessPrice(p) := volWeightExcessPrice
		imbalShortfallPrice(p) := volWeightShortfallPrice

		maxImbalSales(p) := 0
		maxImbalPurchases(p) := 0

		forall(t in TRANCHES) do
			imbalIncSize(p,t) := imbalForIncSize(1)
			imbalDecSize(p,t) := imbalForDecSize(1)
			imbalIncProb(p,t) := imbalForIncCallProb(1,t)
			imbalDecProb(p,t) := imbalForDecCallProb(1,t)
		end-do
	end-do
end-procedure

procedure setupImbalForecast
	case imbalModelType of
		0: setupImbal_Actuals
		1: setupImbal_Dist
		2: setupImbal_Forecast
	end-case
end-procedure



end-model
